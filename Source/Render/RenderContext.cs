///////////////////////////////////////////////////////////
//  RenderContext.cs
//  Implementation of the Class RenderContext
//  Generated by Enterprise Architect
//  Created on:      24-мар-2019 20:54:09
//  Original author: Ivan
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Windows.Media.Imaging;
using System.Windows;
using System.Windows.Media;



namespace System {

    public class ViewPort
    {
        public int Width;
        public int Height;
        
        public ViewPort(int width, int height)
        {
            writeableBmp = BitmapFactory.New(width, height);
        }

        WriteableBitmap writeableBmp;
        public WriteableBitmap WriteableBmp
        {
            get
            {
                return writeableBmp;
            }
        }

        public void Clear()
        {
            writeableBmp.Clear(Colors.White);
        }

        public void Resize(int width, int height)
        {
            writeableBmp = BitmapFactory.New(width, height);
        }
    }

	public class RenderContext {

        private WriteableBitmap bmp;
        public WriteableBitmap Bitmap
        {
            get
            {
                return bmp;
            }
        }

        public RenderContext(WriteableBitmap bitmap)
        {
            bmp = bitmap;
        }

        public Point Offset = new Point(0, 0);

        private const double MaxScale = 10;
        private const double MinScale = 0.2;
        public double scale = 1.0d;
        public double Scale
        {
            get
            {
                return scale;
            }
            set
            {
                /* Apply saturation */
                if (value > MaxScale)
                {
                    scale = MaxScale;
                }
                else if (value < MinScale)
                {
                    scale = MinScale;
                }
                else
                {
                    scale = value;
                }
            }
        }

		~RenderContext(){

		}

        public void Clear()
        {
            bmp.Clear(Colors.White);
        }

        public void DrawLine(double startX, double startY, double endX, double endY, Color color, double thickness)
        {
            startX = Offset.X + startX * Scale;
            startY = Offset.Y + startY * Scale;
            endX = Offset.X + endX * Scale;
            endY = Offset.Y + endY * Scale;
            int thick = (int)(thickness * Scale);
            if (thick < 1)
            {
                thick = 1;
            }
            bmp.DrawLineAa((int)startX, (int)startY, (int)endX, (int)endY, color, thick);
        }

        public void DrawLine(double startX, double startY, double endX, double endY, Color color)
        {
            startX = Offset.X + startX * Scale;
            startY = Offset.Y + startY * Scale;
            endX = Offset.X + endX * Scale;
            endY = Offset.Y + endY * Scale;
            bmp.DrawLine((int)startX, (int)startY, (int)endX, (int)endY, color);
        }

        public void DrawRectangle(double startX, double startY, double endX, double endY, Color color)
        {            
            startX = Offset.X + startX * Scale;
            startY = Offset.Y + startY * Scale;
            endX = Offset.X + endX * Scale;
            endY = Offset.Y + endY * Scale;
            bmp.DrawRectangle((int)startX, (int)startY, (int)endX, (int)endY, color);
        }

        public void DrawFillRectangle(double startX, double startY, double endX, double endY, Color color)
        {
            startX = Offset.X + startX * Scale;
            startY = Offset.Y + startY * Scale;
            endX = Offset.X + endX * Scale;
            endY = Offset.Y + endY * Scale;
            bmp.FillRectangle((int)startX, (int)startY, (int)endX, (int)endY, color);           
        }

        public void DrawEllipse(double startX, double startY, double endX, double endY, Color color)
        {
            startX = Offset.X + startX * Scale;
            startY = Offset.Y + startY * Scale;
            endX = Offset.X + endX * Scale;
            endY = Offset.Y + endY * Scale;
            bmp.DrawEllipse((int)startX, (int)startY, (int)endX, (int)endY, color);    
        }

        public void DrawEllipseCentered(double startX, double startY, double endX, double endY, Color color, int thickness)
        {
            int count = (int)(thickness * Scale);
            if (count < 1)
            {
                count = 1;
            }
            if (count == 1)
            {
                startX = Offset.X + startX * Scale;
                startY = Offset.Y + startY * Scale;
                endX = Offset.X + endX * Scale;
                endY = Offset.Y + endY * Scale;

                double cx = (startX + endX) / 2.0;
                double cy = (startY + endY) / 2.0;
                double xr = Math.Abs(startX - endX) / 2.0;
                double yr = Math.Abs(startY - endY) / 2.0;

                bmp.DrawEllipseCentered((int)cx, (int)cy, (int)xr, (int)yr, color);
            }
            else
            {
                if (count % 2 == 0)
                {
                    count++;
                }
                double step = thickness * Scale / count;
                double half = thickness * Scale / 2.0;

                startX = Offset.X + startX * Scale;
                startY = Offset.Y + startY * Scale;
                endX = Offset.X + endX * Scale;
                endY = Offset.Y + endY * Scale;

                int cx = (int)((startX + endX) / 2.0);
                int cy = (int)((startY + endY) / 2.0);
                int minRad = (int)(Math.Abs(startX - endX) / 2.0 - half);
                int maxRad = (int)(Math.Abs(startX - endX) / 2.0 + half);
                for (int i = minRad; i <= maxRad; i++)
                {
                     bmp.DrawEllipseCentered((int)cx, (int)cy, (int)i, (int)i, color);
                }
            }
        }

        public void DrawFillTriangle(double x1, double y1, double x2, double y2, double x3, double y3, Color color)
        {
            x1 = Offset.X + x1 * Scale;
            x2 = Offset.X + x2 * Scale;
            x3 = Offset.X + x3 * Scale;
            y1 = Offset.Y + y1 * Scale;
            y2 = Offset.Y + y2 * Scale;
            y3 = Offset.Y + y3 * Scale;

            bmp.FillTriangle((int)x1, (int)y1, (int)x2, (int)y2, (int)x3, (int)y3, color);
        }

        public Point GetImageCoordinate(Point worldCoordinate)
        {
            Point imageCoord = new Point(0, 0);

            imageCoord.X = Offset.X + worldCoordinate.X * Scale;
            imageCoord.Y = Offset.Y + worldCoordinate.Y * Scale;

            return imageCoord;
        }

        public Point GetWorldCoordinate(Point imageCoordinate)
        {
            Point sceneCoord = new Point(0, 0);

            //CoordX = offset.X + RealCoord * scale 
            // =>
            // RealCoord = ( CoordX - offsetX ) / scale

            sceneCoord.X = (imageCoordinate.X - Offset.X) / Scale;
            sceneCoord.Y = (imageCoordinate.Y - Offset.Y) / Scale;

            return sceneCoord;
        }
	}//end RenderContext

}//end namespace System